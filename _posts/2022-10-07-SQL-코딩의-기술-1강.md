---
title: SQL 코딩의 기술 1강. 데이터 모델 설계
date: 2022-10-07 13:00:00 +0900
categories: [Book, SQL 코딩의 기술]
tags: [SQL, 데이터베이스, SQL 코딩의 기술]
description: SQL 코딩의 기술 1강 내용 정리
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true

---

<table align="center" width="100" height="50">
    <tr>
        <td align="center"><img src="http://image.yes24.com/goods/56947533/XL"></td>
    </tr>
</table>

## 간단한 책 소개
> 이 책은 데이터베이스를 다룰 수 있는 SQL의 개념과 사용 방법을 소개하고 있습니다. \
> 대표적인 DBMS인 오라클, SQL Server, MySQL, PostgreSQL 등을 비교하면서 보여줍니다. \
> 회사를 다녀보니, 데이터를 다루는 과정에서는 파이썬보다 SQL과 DB에 대한 이해가 더 필요하다는 것을 느꼈습니다. \
> 따라서 데이터베이스를 다룰 수 있는 (거의 유일한) SQL을 학습하며, DB에 대한 이해도를 높이려고 합니다. \
> 이 책에서는 다양한 DBMS를 소개하고 있지만, 실제로 가장 많이 사용되고 있고 제 필요에 따라서, \
> DB의 기초 내용과 MySQL, PostgreSQL 등의 내용을 중점적으로 살펴 볼 예정입니다. 
* [SQL 코딩의 기술](http://www.yes24.com/Product/Goods/56947533)
* [SQL 코딩의 기술 Github 링크](https://github.com/gilbutITbook/006882)

<br/>

|Chapter|Title|Main Topics|
|:---:|:---:|:---:|
|1강|데이터 모델 설계|기본키, 외래키, 중복 데이터 제거, 정규화, 역정규화|
|2강|인덱스 설계와 프로그램적 처리|인덱스, 트리거, 선언적 제약 조건|
|3강|데이터 모델 설계를 변경할 수 없는 경우|뷰, ETL, 요약 테이블, UNION|
|4강|데이터 필터링과 검색|관계 대수, CASE, 다중 조건 문제, 데이터 분할, 사거블 쿼리|
|5강|집계|GROUP BY, HAVING, DISTINCT, 윈도우 함수, 이동 집계|
|6강|서브쿼리|서브쿼리, CTE, 조인|
|7강|메타데이터 획득, 분석|메타데이터 수집 방법, 실행 계획의 작동 원리|
|8강|카티전 곱|로우 조합|
|9강|탤리 테이블|윈도우 함수, 날짜 테이블, 피벗|
|10강|계층형 데이터 모델링|인접 리스트 모델, 중첩 집합|
|Appendix|-|데이터 타입, 산술 연산, 함수|

<br/>

---

## <font color=orange>Chapter 1. 데이터 모델 설계</font>

### <font color=skyblue>Better way 1 - 모든 테이블에 기본키가 있는지 확인하자</font>

- 관계형 모델을 따르기 위해서는 한 테이블에 있는 특정 row와 다른 row를 구별할 수 있어야 함
- 테이블에 기본키가 없으면, 일관성 없는 데이터가 쌓여 쿼리 속도가 느리고, 정확한 정보 조회가 불가능 할 수도 있음
- So, 모든 테이블에는 column 한 개 이상으로 구성된 `기본키 (Primary Key)`가 필요
    - 기본키는 row마다 유일해야 함
    - 기본키는 null 값을 가질 수 없음
    - 기본키는 안정적인 값이어야 함 (값을 갱신할 필요가 없음)
    - 기본키는 가능한 간단한 형태이어야 함
- 기본키 설정을 하기 위한 가장 일반적인 방법은 의미 없는 숫자 데이터로 자동 생성되는 컬럼을 기본키로 만드는 것
    - RDBMS에 따라 이름이 구분되는데, DB2, SQL Server, 오라클 12c에서는 `IDENTITY`
    - 액세스에서는 `AutoNumber`, MySQL,에서는 `AUTO_INCREMENT`, PostgreSQL에서는 `serial` 컬럼
- RDBMS에서 **참조 무결성 (Reference Integrity, RI)**이라는 개념은 매우 중요
    - RI를 준수한다는 것은 null이 아닌 외래키 (Foreign Key)가 설정된 자식 테이블의 각 레코드와 일치하는 레코드가 부모 테이블에 존재한다는 것
    - ex) Orders 테이블에서 고객 정보 컬럼에 외래키를 설정하여 Customers 테이블의 기본키와 연결된 것
    - 이렇게 되면, 같은 이름을 가진 고객이 있어도 Customers 테이블의 각 로우는 유일하기 때문에 고객 식별 가능
- 복합 기본키 (Compound Primary Key)는 다음의 이유로 효율성이 떨어지므로 지양하기
    - 기본키를 정의 할 때, 해당 컬럼에 유일한 인덱스를 만드는데, 컬럼 두 개 이상에 인덱스를 만드는게 비효율적
    - 기본키로 조인을 수행하는데, 기본키가 여러 컬럼으로 구성되면 쿼리가 복잡하고 느려짐

### <font color=skyblue>Better way 2 - 중복으로 저장된 데이터 항목을 제거하자</font>

- 데이터가 중복으로 저장된다면?
    - 일관되지 않은 데이터 이슈
    - 비정상적인 삽입, 갱신, 삭제 처리 이슈
    - 디스크 공간 낭비 이슈
- **정규화 (Normalization)**
    - 중복 데이터를 저장하면서 발생하는 문제를 없애려고 정보를 주제 (subject) 별로 분할하는 프로세스
    - 여기서 '중복'이라는 것은 사용자가 동일한 데이터를 한 군데 이상에서 입력하는 것을 뜻함
    - 정규화의 목표는 한 DB에서 동일한 테이블이든, 다른 테이블이든 반복되는 데이터를 최소화하는 것
- 외래키 제약 조건: 복수의 테이블 사이에 관계를 선언함으로써 데이터의 무결성을 보장해 주는 역할

<figure>
    <img src="https://thebook.io/img/006882/038.jpg">
    <figcaption align="center">그림 1-3 단일 테이블의 중복 데이터</figcaption>
</figure>
<figure>
    <img src="https://thebook.io/img/006882/040.jpg">
    <figcaption align="center">그림 1-4 주제 별로 데이터를 테이블에서 분리</figcaption>
</figure>

위 1-3 그림에서 볼 수 있는 것처럼 기존에는 정규화 되어 있지 않고, `CustomerSales` 라는 하나의 테이블로 고객 정보와 종업원 정보, 구매 정보 등이 관리되고 있었음. 이 경우에는 고객이 물건을 구매하는 경우에 PurchaseDate에 관련된 정보만 추가되는 것이 아니라, 다른 모든 컬럼들도 영향을 받고 있음. 게다가 고객 정보가 똑같은데, 데이터가 다르게 들어오는 경우에는 처리하는게 복잡하게 될 수 있음. 

따라서 1-4 그림처럼 주제 (subject) 별로 분할하는 **정규화** 과정을 수행하여, `Customers, Employees, AutomobileModels, SalesTransactions` 테이블로 나눠서 관리할 수 있음. 그러면서 기본키와 외래키를 통해 데이터의 중복을 제거하고, 효율적으로 관리할 수 있음. 또한 아래 쿼리를 통해 데이터를 다시 1-3 그림처럼 복구할 수도 있음.

```sql
SELECT st.SalesID, c.CustFirstName, c.CustLastName, c.Address,
  c.City, c.Phone, st.PurchaseDate, m.ModelYear, m.Model, e.SalesPerson
FROM SalesTransactions st
  INNER JOIN Customers c
    ON c.CustomerID = st.CustomerID
  INNER JOIN Employees e
    ON e.EmployeeID = st.SalesPersonID
  INNER JOIN AutomobileModels m
    ON m.ModelID = st.ModelID;
```

### <font color=skyblue>Better way 3 - 반복 그룹을 제거하자</font>

- `영향도 (비용) 측면에서 컬럼은 비싸고, 로우는 싸다.`
- DB 정규화의 목표는 데이터의 반복 그룹을 제거하고, 스키마 변경을 최소화 하는 것
- 데이터의 반복 그룹을 제거하면, 인덱싱을 사용하여 데이터 중복을 방지하고, 쿼리도 간소화 할 수 있음
- `UNION, UNION ALL` 쿼리를 활용

<br/>
<br/>

> 출처: SQL 코딩의 기술 책 리뷰