---
title: 프로그래머스 인공지능 데브코스 1주차
date: 2022-09-20 21:00:00 +0900
categories: [프로그래머스 인공지능 데브코스 4기]
tags: [AI, Deep learning, Machine learning, 프로그래머스, 인공지능 데브코스, K-digital training]
description: 프로그래머스 인공지능 데브코스 1주차 강의 기록
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true

---

## 1. [K-Digital-Training] 인공지능 데브코스

### 코드 리뷰 하는 방법

- 깃헙 (GitHub) 사용 방법을 배우자.
    - 브랜치 만들고, 해당 브랜치로 이동 -> `git checkout -b <branch name>`
    - 작업한 내용 커밋 및 메시지 남기기 -> `git commit -a -m <commit message>`
    - 커밋한 내용 브랜치에 푸쉬하기 -> `git push`
    - 깃헙 페이지에서 PR (Pull Request) 생성하기
    - 깃헙 페이지에서 PR 리뷰 및 merge

- 깃헙을 사용하는 이유는 여러 사람들과 함께 작업하기 위함이므로 나름의 규칙을 지키자.
    - 코드 공유 및 리뷰는 **서로 더 나은 코드를 만들기 위한 커뮤니케이션 과정**
    - feature 브랜치 생성 방법 및 규칙, PR의 제목 형태

- 참고할 수 있는 링크
    - [Basic Git commands by Atlassian](https://confluence.atlassian.com/bitbucketserver/basic-git-commands-776639767.html)
    - [코드 리뷰 가이드 by thoughbot, 김용균님 번역](https://edykim.com/ko/post/code-review-guide/)
    - [리뷰어의 의견에 대처하는 방법, Soojin Ro](https://soojin.ro/review/handling-comments)

### 알고리즘 이야기 - 요약

- 얼핏 보기에는 특정 라이브러리나 프레임워크를 잘 다뤄서 서비스를 만드는 코딩이 중요해보인다.
- 하지만 실제 개발자에게 가장 필요한 것 중 하나는 문제 해결 능력의 기반이 되는 **알고리즘**이다.
- 알고리즘은 자신의 논리적 사고나 문제 해결 능력의 기반이 되어줄 수 있다.
- 알고리즘 문제를 풀었다면, 어떻게 풀었는지 정리하고, 다른 사람들의 코드를 많이 보며 배우자.
- 간결하고 가독성 좋은 코드를 작성하자. 일관성 있는 코드를 작성하자.

- 참고할 수 있는 링크
    - [visualgo](https://visualgo.net/ko)
    - [algorithm-visualizer](https://algorithm-visualizer.org/)

## 2. [1주차 - Day1] 어서와! 자료구조와 알고리즘은 처음이지? (1)

### 안녕, 자료구조 & 알고리즘!
- 문자열 (str), 리스트 (list), 사전 (dict), 순서쌍 (tuple), 집합 (set)
- 해결하고자 하는 문제에 따라 최적의 해법은 서로 다를 수 있다. 따라서 자료구조 공부가 필요하다.

- 알고리즘이란?
    - 어떤 문제를 해결하기 위한 절차, 방법, 명령어들의 집합
    - 주어진 문제의 해결을 위한 자료구조와 연산 방법에 대한 선택

### 선형 배열 (Linear Array)
- 배열: 원소들을 순서대로 늘어놓은 것
- 리스트 (배열) 연산 -> 리스트의 길이에 비례하여 선형적으로 시간이 걸림
    - 가장 마지막에 원소 덧붙이기 -> `append()`
    - 가장 마지막 원소 꺼내고, 리스트 반환하기 -> `pop()`
    - 특정 위치에 원소 삽입하기 -> `insert(index위치, 삽입할 값)`
    - 특정 리스트의 위치에 있는 원소 삭제하기 -> `del(리스트[index])`
    - 찾고자 하는 원소 index 탐색하기 -> `index(찾고자 하는 원소)`

### 정렬 (Sort), 탐색 (Search)
- 파이썬 리스트의 정렬
    - sorted(): 내장 함수, 정렬된 새로운 리스트를 얻음
    - sort(): 리스트의 메서드, 해당 리스트를 정렬함
    - 정렬 순서를 반대로 하고 싶은 경우에는 `reverse = True` 조건 추가
    - 문자열로 이루어진 리스트에서 정렬 순서는 사전 순서를 따름

```python
L = [ {'name': 'John', 'score': 83}, {'name': 'Paul', 'score': 92} ]

L.sort(key = lambda x: x['name'])  # name 순서로 정렬
L.sort(key = lambda x: x['score']) # score 순서로 정렬
```

- 선형 탐색 (Linear Search): 앞에서 부터 뒤에까지 순차적으로 탐색하는 방법
    - 값을 찾을 때까지 리스트의 길이만큼 반복
    - 리스트의 길이에 비례하는 시간 소요 -> O(n)
    - 최악의 경우에는 모든 원소를 다 비교해봐야 함

```python
def linear_search(L, x):
    i = 0
    while i < len(L) and L[i] != x:
        i += 1

    if i < len(L): return i
    else: return -1
```

- 이진 탐색 (Binary Search): 탐색하려는 리스트가 이미 정렬된 경우에만 적용 가능 
    - 크기 순으로 정렬되어 있다는 성질 이용
    - 한 번 비교가 일어날 때마다 리스트를 절반씩 줄임 (divide & concuer) -> O(log n)

```python
def binary_search(L, x):
    idx = -1
    lower, upper = 0, len(L) - 1

    while lower <= upper:
        middle = (lower + upper) // 2
        if L[middle] == x: return middle
        elif L[middle] < x: lower = middle + 1
        else: upper = middle - 1
```

### 재귀 알고리즘 기초

- 재귀함수 (Recursive function): 하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 것
- 이진 트리 (Binary trees): 이진 탐색과 유사하게 접근할 수 있음

> 예제 1. 1부터 n까지 모든 자연수의 합 구하기

```python
def sum(n): # O(n)
    if n <= 1: return n          # 종결 조건 (trivial case), 점화식
    else: return n + sum(n - 1)

def sum(n): # O(n)
    s = 0
    while n >= 0:
        s += n
        n -= 1
    return s
```

> 예제 2. 펙토리얼 (!)의 재귀 함수

```python
def factorial(n):
    if n <= 1: return 1
    else: return n * factorial(n - 1)
```

> 예제 3. 피보나치 순열의 재귀 함수

```python
def fibonacci(x):
    if x == 0: return 0
    elif x == 1: return 1
    else: return solution(x - 1) + solution(x - 2)
```

### 재귀 알고리즘 응용

> 예제 1. 조합의 수 계산 - n개의 서로 다른 원소에서 m개를 선택하는 경우의 수

```python
from math import factorial as f

def combi(n, m):
    return f(n) / (f(m) * f(n - m))

def combi(n, m):
    if n == m: return 1
    elif m == 0: return 1
    return combi(n - 1, m) + combi(n - 1, m - 1)
```

### 알고리즘의 복잡도

- 시간 복잡도 (Time Complexity): 문제의 크기와 이를 해결하는데 걸리는 시간 사이의 관계
- 공간 복잡도 (Space Complexity): 문제의 크기와 이를 해결하는데 필요한 메모리 공간 사이의 관계
- 평균 시간 복잡도 (Average Time Complexity): 임의의 입력 패턴을 가정했을 때, 소요되는 시간의 평균
- 최악 시간 복잡도 (Worst-case Time Complexity): 가장 긴 시간을 소요하게 만드는 입력에 따라 소요되는 시간

- **Big-O Notation**: 점근 표기법의 하나 - 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현
    - 입력의 크기가 n 이라고 할 때,
    - O(logn)은 입력의 크기의 로그에 비례하는 시간이 소요된다는 것
    - O(n)은 입력의 크기에 비례하여 시간이 소요된다는 것
    - 계수는 그다지 중요하지 않음

- 선형 시간 알고리즘: n개의 무작위로 나열된 수에서 최댓값을 찾기 위해 선형 탐색 알고리즘 적용 -> O(n)
- 로그 시간 알고리즘: n개의 크기 순으로 정렬된 수에서 특정 값을 찾기 위해 이진 탐색 알고리즘 적용 -> O(logn)
- 이차 시간 알고리즘: 삽입 정렬 (insertion sort) -> O(n^2)
- 보다 낮은 복잡도를 갖는 정렬 알고리즘: 병합 정렬 (merge sort) -> O(nlogn)
- 복잡한 문제: 배낭 문제 (Knapsack problem)

### 연결 리스트 (Linked Lists) (1)

- 추상적 자료구조 (Abstract Data Structures)
    - Data: 정수, 문자열, 레코드
    - A set of operations: 삽입, 삭제, 순회, 정렬, 탐색
- 기본적인 연결 리스트 (Node)는 데이터와 Link (next)를 포함하고 있음
- 연산 정의: 특정 원소 참조, 리스트 순회, 길이 얻어내기, 원소 삽입 및 삭제, 두 리스트 합치기
- 배열과 비교한 연결 리스트

|특징|배열|연결 리스트|
|:---:|:---:|:---:|
|저장 공간|연속한 위치|임의의 위치|
|특성 원소 지칭|매우 간편|선형 탐색과 유사|
|Big-O 표기|O(1)|O(n)|

```python
class LinkedList:
    def __init__(self):
        self.nodeCount = 0
        self.head = None
        self.tail = None

    def getAt(self, pos):
        if pos <= 0 or pos > self.nodeCount: return None
        i = 1
        curr = self.head
        while i < pos:
            curr = curr.next
            i += 1
        return curr
```