---
title: 프로그래머스 인공지능 데브코스 3주차
date: 2022-10-03 10:00:00 +0900
categories: [프로그래머스 인공지능 데브코스 4기]
tags: [AI, Deep learning, Machine learning, 프로그래머스, 인공지능 데브코스, K-digital training]
description: 프로그래머스 인공지능 데브코스 3주차 강의 기록
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true

---

## 1. Numpy 실습

```python
import numpy as np

### Numpy array shape
A = np.array([[1, 2, 3], [3, 4, 5], [6, 3, 4]]) # shape_of_A = (3, 3)

### Numpy one, zero array
A = np.ones(shape=(2, 1, 3))
B = np.zeros(shape=(3, 4, 2))

### Numpy random array
A = np.random.randn(4, 3, 3)
B = np.random.normal(loc=1.56, scale=0.67, size=(5, 6)) # 평균 1.56, 표준편차 0.67
C = np.random.randint(10, 21, size=(3, 4)) # 10부터 20까지 임의의 정수를 담은 배열

### Numpy indexing
arr = np.random.randn(4, 5, 7, 8)
answer = arr[2, 2, 3, 3] # arr의 (2, 2, 3, 3) 번째 요소 값 읽기

### Numpy changing certain element
arr = np.random.randn(5, 3, 3, 6, 7)
arr[1, 2, 2, 3, 4] = 0 # arr의 (1, 2, 2, 3, 4) 번째 요소 값을 0으로 변경

### Numpy addition (+)
arr_A = np.array([[1, 2, 3], [3, 4, 5]])
arr_B = np.ones(shape=(2, 3))
np_result = arr_A + arr_B # A와 B 배열의 합

### Numpy multiply (*)
arr_A = np.array([[3, 6], [2, 7]])
arr_B = np.ones(shape=(2, 2))
np_result = arr_A * arr_B # A와 B 배열의 곱
```

- 지금까지의 연산은 shape이 같은 두 배열 사이에서 적용된 것들
- 즉, 두 배열 사이에 shape이 다르다면, 연산이 제대로 동작하지 않음
- 그런데 Numpy에서 같은 shape이 아니더라도 연산이 가능한 경우가 있음
- Numpy에서 배열의 shape이 다르더라도 자동으로 맞춰 연산하는 것을 `브로드캐스팅`이라고 함

```python
import numpy as np

### Numpy dot
A = np.random.randint(1, 4, size=(2, 3))
B = np.random.randint(1, 4, size=(3, 2))
C = np.dot(A, B) # A와 B의 행렬 곱 연산

### Numpy 1d array slicing
arr = [i * j for j in range(10) for i in range(10)]
arr = np.array(arr)
result = arr[42:57] # arr의 42번 인덱스부터 56번 인덱스까지 슬라이싱
arr[35:50] = 1      # arr의 35번 인덱스부터 49번 인덱스까지 요소 값을 1로 변경

### Numpy 2d array slicing
arr = [[i * j for i in range(10)] for j in range(10)]
arr = np.array(arr)
result = arr[3:7, 7:10] # arr의 (3, 7)에서 (6, 9)까지 슬라이싱
arr[2:6, 3:8] = 0       # arr의 (2, 3)부터 (5, 7)까지 요소 값을 0으로 변경

### Numpy 2d array가 주어질 때, (y1, x1)에서 (y2, x2)까지 요소에 2를 곱한 배열 반환
def solution(arr, y1, x1, y2, x2):
    arr[y1:y2+1, x1:x2+1] *= 2
    return arr

### Numpy 내적 연산
def solution(x, w, b):
    return np.dot(x, w) + b    

### Numpy bool 인덱싱
arr = np.random.randint(0, 100, size=(5, 6, 3))
result = arr[(arr > 10) & (arr <= 20)] # 10보다 크고, 20보다 작거나 같은 요소 추출

### Numpy 관계 연산
A = np.random.randint(0, 100, size=(3, 3, 3))
result = (A == 52) | (A == 1) # A 안에 52 또는 1인 요소와 같은 위치에 True, 다른 곳은 False

### Numpy 배열 만들기
A = [1, 2, 3, 4, 5]
np_A = np.array(A) # np.array()를 이용하여 numpy.ndarray 타입의 배열 만들기

### Numpy matmul() 함수
a = np.random.randn(3, 16, 64)
b = np.random.randn(3, 64, 8)
dot_result = np.dot(a, b)
matmul_result = np.matmul(a, b)

### Numpy 브로드캐스팅 스칼라
a = np.array([[2, 7, 5], [6, 6, 1]])
result = a * 2 # 행렬 a에 모든 요소 별로 2를 곱함

### Numpy any(), all()
arr = np.random.randint(0, 100, size=(3, 3, 3))
result1 = ((arr == 52) | (arr == 1)).any() # arr에 52 또는 1이 있는지 확인
result2 = (arr[0, :, :] >= 20).all() # 해당 범위의 요소가 모두 20 이상의 수를 가지고 있는지 확인
```

### Numpy의 np.dot()과 np.matmul()의 차이


## 2. Python으로 데이터 다루기 - Numpy

## 3. Python으로 데이터 다루기 - Pandas

## 4. Python으로 시각화하기 - Matplotlib

## 5. Python으로 시각화 프로젝트

<br/>
<br/>

> 출처: 프로그래머스 인공지능 데브코스 4기 3주차 강의 -> [강의 내용 정리 깃허브 링크](https://github.com/Paul-scpark/AI-dev-course/tree/main/3%EC%A3%BC%EC%B0%A8)